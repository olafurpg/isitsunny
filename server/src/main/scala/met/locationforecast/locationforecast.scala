// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package met.locationforecast


/** Schema to be used for
			presenting weather parameters for specific locations.
	            
*/
case class Weatherdata(meta: Option[met.locationforecast.MetaType] = None,
  product: Seq[met.locationforecast.ProductType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val created = attributes("@created").as[javax.xml.datatype.XMLGregorianCalendar]
}

      


/** Element for naming the
		    forecast models used, and the respective time
		    intervals for each of them.
		     
*/
case class MetaType(model: Seq[met.locationforecast.ModelType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val licenseurl = attributes.get("@licenseurl") map { _.as[java.net.URI] }
}

      


case class ModelType(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val name = attributes.get("@name") map { _.as[String] }
  lazy val termin = attributes.get("@termin") map { _.as[String] }
  lazy val runended = attributes.get("@runended") map { _.as[String] }
  lazy val nextrun = attributes.get("@nextrun") map { _.as[String] }
  lazy val from = attributes.get("@from") map { _.as[String] }
  lazy val to = attributes.get("@to") map { _.as[String] }
}

      

trait Class

object Class {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Class = value match {
    case "pointData" => PointData
    case "extremes" => Extremes
    case "forestfireindex" => Forestfireindex
    case "uvforecast" => Uvforecast
    case "tidalwater" => TidalwaterValue
    case "buoy" => Buoy
    case "stavernodden" => Stavernodden
    case "seaapproachforecast" => Seaapproachforecast
    case "temperatureverification" => Temperatureverification

  }
}

case object PointData extends Class { override def toString = "pointData" }
case object Extremes extends Class { override def toString = "extremes" }
case object Forestfireindex extends Class { override def toString = "forestfireindex" }
case object Uvforecast extends Class { override def toString = "uvforecast" }
case object TidalwaterValue extends Class { override def toString = "tidalwater" }
case object Buoy extends Class { override def toString = "buoy" }
case object Stavernodden extends Class { override def toString = "stavernodden" }
case object Seaapproachforecast extends Class { override def toString = "seaapproachforecast" }
case object Temperatureverification extends Class { override def toString = "temperatureverification" }


/** Element describing a weatherproduct by
	             time-elements, location-elements and a set of weather-elements.
	        
*/
case class ProductType(time: Seq[met.locationforecast.TimeType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val classValue = attributes("@class").as[Class]
}

      

trait Datatype

object Datatype {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Datatype = value match {
    case "observation" => Observation
    case "forecast" => Forecast

  }
}

case object Observation extends Datatype { override def toString = "observation" }
case object Forecast extends Datatype { override def toString = "forecast" }


/** Element containing forecasts
		for the specified time and duration.
		
*/
case class TimeType(location: Seq[met.locationforecast.LocationType] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val from = attributes("@from").as[javax.xml.datatype.XMLGregorianCalendar]
  lazy val to = attributes("@to").as[javax.xml.datatype.XMLGregorianCalendar]
  lazy val datatype = attributes.get("@datatype") map { _.as[Datatype] }
}

      


case class Temperature(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val unit = attributes("@unit").as[String]
  lazy val valueAttribute = attributes("@value").as[BigDecimal]
  lazy val id = attributes.get("@id") map { _.as[String] }
}

      


/** Element denoting the cloudiness in percent or eights.
			
*/
case class Cloudiness(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val eights = attributes.get("@eights") map { _.as[BigInt] }
  lazy val percent = attributes.get("@percent") map { _.as[String] }
  lazy val id = attributes.get("@id") map { _.as[String] }
}

      


/** Element denoting the wind speed by name, meters per second or the Beaufort scale.
		
*/
case class Windspeed(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val mps = attributes("@mps").as[BigDecimal]
  lazy val name = attributes.get("@name") map { _.as[String] }
  lazy val beaufort = attributes.get("@beaufort") map { _.as[BigInt] }
  lazy val id = attributes.get("@id") map { _.as[String] }
}

      


/** Element denoting the precipitation in mm.
		
*/
case class Precipitation(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val unit = attributes("@unit").as[String]
  lazy val valueAttribute = attributes("@value").as[BigDecimal]
  lazy val minvalue = attributes.get("@minvalue") map { _.as[Float] }
  lazy val maxvalue = attributes.get("@maxvalue") map { _.as[Float] }
  lazy val probability = attributes.get("@probability") map { _.as[Float] }
  lazy val id = attributes.get("@id") map { _.as[String] }
}

      


case class Groundcover(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val number = attributes("@number").as[BigInt]
  lazy val name = attributes.get("@name") map { _.as[String] }
  lazy val id = attributes.get("@id") map { _.as[String] }
}

      


case class Pressure(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val unit = attributes("@unit").as[String]
  lazy val valueAttribute = attributes("@value").as[BigDecimal]
  lazy val id = attributes.get("@id") map { _.as[String] }
}

      


case class Unit_value(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val unit = attributes("@unit").as[String]
  lazy val valueAttribute = attributes("@value").as[Float]
}

      


case class Uv(uvi_clear: met.locationforecast.Unit_value,
  uvi_partly_cloudy: met.locationforecast.Unit_value,
  uvi_cloudy: met.locationforecast.Unit_value,
  uvi_forecast: met.locationforecast.Unit_value,
  ozon: met.locationforecast.Unit_value,
  snowcover: met.locationforecast.Unit_value,
  cloudcover: met.locationforecast.Unit_value,
  albedo: met.locationforecast.Unit_value,
  solar_zenith: met.locationforecast.Unit_value)
      


case class Score(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val unit = attributes.get("@unit") map { _.as[String] }
  lazy val overall = attributes.get("@overall") map { _.as[BigInt] }
  lazy val very_good = attributes.get("@very_good") map { _.as[BigInt] }
  lazy val good = attributes.get("@good") map { _.as[BigInt] }
  lazy val mediocre = attributes.get("@mediocre") map { _.as[BigInt] }
}

      


case class Tidalwater(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val unit = attributes.get("@unit") map { _.as[String] }
  lazy val tidal = attributes("@tidal").as[BigInt]
  lazy val weathercorrection = attributes.get("@weathercorrection") map { _.as[BigInt] }
}

      


/** Element denoting the wind direction by angle or 
						compass direction. 
						
*/
case class WindDirection(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val deg = attributes("@deg").as[BigDecimal]
  lazy val name = attributes.get("@name") map { _.as[String] }
  lazy val id = attributes.get("@id") map { _.as[String] }
}

      


case class StateOfTheSea(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val number = attributes("@number").as[BigInt]
  lazy val meter = attributes.get("@meter") map { _.as[String] }
  lazy val name = attributes.get("@name") map { _.as[String] }
  lazy val id = attributes.get("@id") map { _.as[String] }
}

      


case class SnowDepth(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val cm = attributes("@cm").as[BigDecimal]
  lazy val id = attributes.get("@id") map { _.as[String] }
}

      


/** Element denoting a weather symbol by name or number.
						
*/
case class Weather(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val name = attributes.get("@name") map { _.as[String] }
  lazy val number = attributes("@number").as[BigInt]
  lazy val id = attributes.get("@id") map { _.as[String] }
  lazy val symbol = attributes.get("@symbol") map { _.as[BigInt] }
}

      


case class Symbol(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val id = attributes.get("@id") map { _.as[String] }
  lazy val name = attributes.get("@name") map { _.as[String] }
  lazy val number = attributes("@number").as[BigInt]
}

      


case class Forestu45fire(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val unit = attributes.get("@unit") map { _.as[String] }
  lazy val valueAttribute = attributes.get("@value") map { _.as[String] }
}

      


/** Element containing weather parameters for this location
			
*/
case class LocationType(locationtypesequence1: Seq[met.locationforecast.LocationTypeSequence1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val id = attributes.get("@id") map { _.as[String] }
  lazy val name = attributes.get("@name") map { _.as[String] }
  lazy val stationid = attributes.get("@stationid") map { _.as[BigInt] }
  lazy val country = attributes.get("@country") map { _.as[String] }
  lazy val county = attributes.get("@county") map { _.as[String] }
  lazy val latitude = attributes.get("@latitude") map { _.as[String] }
  lazy val longitude = attributes.get("@longitude") map { _.as[String] }
  lazy val altitude = attributes.get("@altitude") map { _.as[String] }
}

      

case class LocationTypeSequence1(groundCover: Option[met.locationforecast.Groundcover] = None,
  pressure: Option[met.locationforecast.Pressure] = None,
  maximumPrecipitation: Option[met.locationforecast.Precipitation] = None,
  highestTemperature: Option[met.locationforecast.Temperature] = None,
  lowestTemperature: Option[met.locationforecast.Temperature] = None,
  precipitation: Option[met.locationforecast.Precipitation] = None,
  fog: Option[met.locationforecast.Cloudiness] = None,
  cloudiness: Option[met.locationforecast.Cloudiness] = None,
  lowClouds: Option[met.locationforecast.Cloudiness] = None,
  mediumClouds: Option[met.locationforecast.Cloudiness] = None,
  highClouds: Option[met.locationforecast.Cloudiness] = None,
  temperature: Option[met.locationforecast.Temperature] = None,
  dewpointTemperature: Option[met.locationforecast.Temperature] = None,
  minTemperature: Option[met.locationforecast.Temperature] = None,
  minTemperatureDay: Option[met.locationforecast.Temperature] = None,
  minTemperatureNight: Option[met.locationforecast.Temperature] = None,
  maxTemperature: Option[met.locationforecast.Temperature] = None,
  maxTemperatureDay: Option[met.locationforecast.Temperature] = None,
  maxTemperatureNight: Option[met.locationforecast.Temperature] = None,
  uv: Option[met.locationforecast.Uv] = None,
  tidalwater: Option[met.locationforecast.Tidalwater] = None,
  currentDirection: Option[met.locationforecast.Unit_value] = None,
  maxWaveHeight: Option[met.locationforecast.Unit_value] = None,
  surfaceTemperature: Option[met.locationforecast.Unit_value] = None,
  waveDirection: Option[met.locationforecast.Unit_value] = None,
  wavePeriod: Option[met.locationforecast.Unit_value] = None,
  waveHeight: Option[met.locationforecast.Unit_value] = None,
  humidity: Option[met.locationforecast.Unit_value] = None,
  bias: Option[met.locationforecast.Unit_value] = None,
  numberofobservations: Option[met.locationforecast.Unit_value] = None,
  meanabsoluteerror: Option[met.locationforecast.Unit_value] = None,
  score: Option[met.locationforecast.Score] = None,
  windDirection: Option[met.locationforecast.WindDirection] = None,
  windSpeed: Option[met.locationforecast.Windspeed] = None,
  windGust: Option[met.locationforecast.Windspeed] = None,
  maxWindSpeed: Option[met.locationforecast.Windspeed] = None,
  stateOfTheSea: Option[met.locationforecast.StateOfTheSea] = None,
  snowDepth: Option[met.locationforecast.SnowDepth] = None,
  weather: Option[met.locationforecast.Weather] = None,
  symbol: Option[met.locationforecast.Symbol] = None,
  forestu45fire: Option[met.locationforecast.Forestu45fire] = None,
  windProbability: Option[met.locationforecast.Unit_value] = None,
  temperatureProbability: Option[met.locationforecast.Unit_value] = None,
  symbolProbability: Option[met.locationforecast.Unit_value] = None)

