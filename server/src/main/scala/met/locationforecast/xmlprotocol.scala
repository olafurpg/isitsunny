// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package met.locationforecast

import scala.concurrent.Future


/**
usage:
val obj = scalaxb.fromXML[met.locationforecast.Foo](node)
val document = scalaxb.toXML[met.locationforecast.Foo](obj, "foo", met.locationforecast.defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  implicit lazy val executionContext = scala.concurrent.ExecutionContext.Implicits.global

  val defaultScope = scalaxb.toScope(Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val LocationforecastWeatherdataFormat: scalaxb.XMLFormat[met.locationforecast.Weatherdata] = new DefaultLocationforecastWeatherdataFormat {}
  implicit lazy val LocationforecastMetaTypeFormat: scalaxb.XMLFormat[met.locationforecast.MetaType] = new DefaultLocationforecastMetaTypeFormat {}
  implicit lazy val LocationforecastModelTypeFormat: scalaxb.XMLFormat[met.locationforecast.ModelType] = new DefaultLocationforecastModelTypeFormat {}
  implicit lazy val LocationforecastClassFormat: scalaxb.XMLFormat[met.locationforecast.Class] = new DefaultLocationforecastClassFormat {}
  implicit lazy val LocationforecastProductTypeFormat: scalaxb.XMLFormat[met.locationforecast.ProductType] = new DefaultLocationforecastProductTypeFormat {}
  implicit lazy val LocationforecastDatatypeFormat: scalaxb.XMLFormat[met.locationforecast.Datatype] = new DefaultLocationforecastDatatypeFormat {}
  implicit lazy val LocationforecastTimeTypeFormat: scalaxb.XMLFormat[met.locationforecast.TimeType] = new DefaultLocationforecastTimeTypeFormat {}
  implicit lazy val LocationforecastTemperatureFormat: scalaxb.XMLFormat[met.locationforecast.Temperature] = new DefaultLocationforecastTemperatureFormat {}
  implicit lazy val LocationforecastCloudinessFormat: scalaxb.XMLFormat[met.locationforecast.Cloudiness] = new DefaultLocationforecastCloudinessFormat {}
  implicit lazy val LocationforecastWindspeedFormat: scalaxb.XMLFormat[met.locationforecast.Windspeed] = new DefaultLocationforecastWindspeedFormat {}
  implicit lazy val LocationforecastPrecipitationFormat: scalaxb.XMLFormat[met.locationforecast.Precipitation] = new DefaultLocationforecastPrecipitationFormat {}
  implicit lazy val LocationforecastGroundcoverFormat: scalaxb.XMLFormat[met.locationforecast.Groundcover] = new DefaultLocationforecastGroundcoverFormat {}
  implicit lazy val LocationforecastPressureFormat: scalaxb.XMLFormat[met.locationforecast.Pressure] = new DefaultLocationforecastPressureFormat {}
  implicit lazy val LocationforecastUnit_valueFormat: scalaxb.XMLFormat[met.locationforecast.Unit_value] = new DefaultLocationforecastUnit_valueFormat {}
  implicit lazy val LocationforecastUvFormat: scalaxb.XMLFormat[met.locationforecast.Uv] = new DefaultLocationforecastUvFormat {}
  implicit lazy val LocationforecastScoreFormat: scalaxb.XMLFormat[met.locationforecast.Score] = new DefaultLocationforecastScoreFormat {}
  implicit lazy val LocationforecastTidalwaterFormat: scalaxb.XMLFormat[met.locationforecast.Tidalwater] = new DefaultLocationforecastTidalwaterFormat {}
  implicit lazy val LocationforecastWindDirectionFormat: scalaxb.XMLFormat[met.locationforecast.WindDirection] = new DefaultLocationforecastWindDirectionFormat {}
  implicit lazy val LocationforecastStateOfTheSeaFormat: scalaxb.XMLFormat[met.locationforecast.StateOfTheSea] = new DefaultLocationforecastStateOfTheSeaFormat {}
  implicit lazy val LocationforecastSnowDepthFormat: scalaxb.XMLFormat[met.locationforecast.SnowDepth] = new DefaultLocationforecastSnowDepthFormat {}
  implicit lazy val LocationforecastWeatherFormat: scalaxb.XMLFormat[met.locationforecast.Weather] = new DefaultLocationforecastWeatherFormat {}
  implicit lazy val LocationforecastSymbolFormat: scalaxb.XMLFormat[met.locationforecast.Symbol] = new DefaultLocationforecastSymbolFormat {}
  implicit lazy val LocationforecastForestu45fireFormat: scalaxb.XMLFormat[met.locationforecast.Forestu45fire] = new DefaultLocationforecastForestu45fireFormat {}
  implicit lazy val LocationforecastLocationTypeFormat: scalaxb.XMLFormat[met.locationforecast.LocationType] = new DefaultLocationforecastLocationTypeFormat {}
  implicit lazy val LocationforecastLocationTypeSequence1Format: scalaxb.XMLFormat[met.locationforecast.LocationTypeSequence1] = new DefaultLocationforecastLocationTypeSequence1Format {}

  trait DefaultLocationforecastWeatherdataFormat extends scalaxb.ElemNameParser[met.locationforecast.Weatherdata] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[met.locationforecast.Weatherdata] =
      phrase(opt(scalaxb.ElemName(None, "meta")) ~ 
      safeRep(scalaxb.ElemName(None, "product")) ^^
      { case p1 ~ p2 =>
      met.locationforecast.Weatherdata(p1.headOption map { scalaxb.fromXML[met.locationforecast.MetaType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[met.locationforecast.ProductType](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@created").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](x, scalaxb.ElemName(node) :: stack)) } map { "@created" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: met.locationforecast.Weatherdata, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@created", _) => attr = scala.xml.Attribute(null, "created", __obj.created.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Weatherdata, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.meta map { scalaxb.toXML[met.locationforecast.MetaType](_, None, Some("meta"), __scope, false) } getOrElse {Nil},
        __obj.product flatMap { scalaxb.toXML[met.locationforecast.ProductType](_, None, Some("product"), __scope, false) })

  }

  trait DefaultLocationforecastMetaTypeFormat extends scalaxb.ElemNameParser[met.locationforecast.MetaType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("metaType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[met.locationforecast.MetaType] =
      phrase(safeRep(scalaxb.ElemName(None, "model")) ^^
      { case p1 =>
      met.locationforecast.MetaType(p1.toSeq map { scalaxb.fromXML[met.locationforecast.ModelType](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@licenseurl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@licenseurl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: met.locationforecast.MetaType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@licenseurl", _) => __obj.licenseurl foreach { x => attr = scala.xml.Attribute(null, "licenseurl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.MetaType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.model flatMap { scalaxb.toXML[met.locationforecast.ModelType](_, None, Some("model"), __scope, false) })

  }

  trait DefaultLocationforecastModelTypeFormat extends scalaxb.XMLFormat[met.locationforecast.ModelType] with scalaxb.CanWriteChildNodes[met.locationforecast.ModelType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.ModelType] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.ModelType(scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@termin").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@termin" -> _ },
        (node \ "@runended").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@runended" -> _ },
        (node \ "@nextrun").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@nextrun" -> _ },
        (node \ "@from").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@from" -> _ },
        (node \ "@to").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@to" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.ModelType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@termin", _) => __obj.termin foreach { x => attr = scala.xml.Attribute(null, "termin", x.toString, attr) }
        case ("@runended", _) => __obj.runended foreach { x => attr = scala.xml.Attribute(null, "runended", x.toString, attr) }
        case ("@nextrun", _) => __obj.nextrun foreach { x => attr = scala.xml.Attribute(null, "nextrun", x.toString, attr) }
        case ("@from", _) => __obj.from foreach { x => attr = scala.xml.Attribute(null, "from", x.toString, attr) }
        case ("@to", _) => __obj.to foreach { x => attr = scala.xml.Attribute(null, "to", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.ModelType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  def buildLocationforecastClassFormat = new DefaultLocationforecastClassFormat {}
  trait DefaultLocationforecastClassFormat extends scalaxb.XMLFormat[met.locationforecast.Class] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Class] = seq match {
      case elem: scala.xml.Elem => Right(met.locationforecast.Class.fromString(elem.text, elem.scope))
      case _ => Right(met.locationforecast.Class.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: met.locationforecast.Class, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultLocationforecastProductTypeFormat extends scalaxb.ElemNameParser[met.locationforecast.ProductType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("productType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[met.locationforecast.ProductType] =
      phrase(safeRep(scalaxb.ElemName(None, "time")) ^^
      { case p1 =>
      met.locationforecast.ProductType(p1.toSeq map { scalaxb.fromXML[met.locationforecast.TimeType](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[met.locationforecast.Class](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: met.locationforecast.ProductType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@class", _) => attr = scala.xml.Attribute(null, "class", __obj.classValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.ProductType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.time flatMap { scalaxb.toXML[met.locationforecast.TimeType](_, None, Some("time"), __scope, false) })

  }

  def buildLocationforecastDatatypeFormat = new DefaultLocationforecastDatatypeFormat {}
  trait DefaultLocationforecastDatatypeFormat extends scalaxb.XMLFormat[met.locationforecast.Datatype] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Datatype] = seq match {
      case elem: scala.xml.Elem => Right(met.locationforecast.Datatype.fromString(elem.text, elem.scope))
      case _ => Right(met.locationforecast.Datatype.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: met.locationforecast.Datatype, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultLocationforecastTimeTypeFormat extends scalaxb.ElemNameParser[met.locationforecast.TimeType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("timeType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[met.locationforecast.TimeType] =
      phrase(safeRep(scalaxb.ElemName(None, "location")) ^^
      { case p1 =>
      met.locationforecast.TimeType(p1.toSeq map { scalaxb.fromXML[met.locationforecast.LocationType](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@from").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](x, scalaxb.ElemName(node) :: stack)) } map { "@from" -> _ },
        (node \ "@to").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](x, scalaxb.ElemName(node) :: stack)) } map { "@to" -> _ },
        (node \ "@datatype").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[met.locationforecast.Datatype](x, scalaxb.ElemName(node) :: stack)) } map { "@datatype" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: met.locationforecast.TimeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@from", _) => attr = scala.xml.Attribute(null, "from", __obj.from.toString, attr)
        case ("@to", _) => attr = scala.xml.Attribute(null, "to", __obj.to.toString, attr)
        case ("@datatype", _) => __obj.datatype foreach { x => attr = scala.xml.Attribute(null, "datatype", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.TimeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.location flatMap { scalaxb.toXML[met.locationforecast.LocationType](_, None, Some("location"), __scope, false) })

  }

  trait DefaultLocationforecastTemperatureFormat extends scalaxb.XMLFormat[met.locationforecast.Temperature] with scalaxb.CanWriteChildNodes[met.locationforecast.Temperature] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Temperature] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Temperature(scala.collection.immutable.ListMap(List(
        (node \ "@unit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@unit" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Temperature, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@unit", _) => attr = scala.xml.Attribute(null, "unit", __obj.unit.toString, attr)
        case ("@value", _) => attr = scala.xml.Attribute(null, "value", __obj.valueAttribute.toString, attr)
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Temperature, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastCloudinessFormat extends scalaxb.XMLFormat[met.locationforecast.Cloudiness] with scalaxb.CanWriteChildNodes[met.locationforecast.Cloudiness] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Cloudiness] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Cloudiness(scala.collection.immutable.ListMap(List(
        (node \ "@eights").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@eights" -> _ },
        (node \ "@percent").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@percent" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Cloudiness, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@eights", _) => __obj.eights foreach { x => attr = scala.xml.Attribute(null, "eights", x.toString, attr) }
        case ("@percent", _) => __obj.percent foreach { x => attr = scala.xml.Attribute(null, "percent", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Cloudiness, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastWindspeedFormat extends scalaxb.XMLFormat[met.locationforecast.Windspeed] with scalaxb.CanWriteChildNodes[met.locationforecast.Windspeed] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Windspeed] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Windspeed(scala.collection.immutable.ListMap(List(
        (node \ "@mps").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@mps" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@beaufort").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@beaufort" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Windspeed, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@mps", _) => attr = scala.xml.Attribute(null, "mps", __obj.mps.toString, attr)
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@beaufort", _) => __obj.beaufort foreach { x => attr = scala.xml.Attribute(null, "beaufort", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Windspeed, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastPrecipitationFormat extends scalaxb.XMLFormat[met.locationforecast.Precipitation] with scalaxb.CanWriteChildNodes[met.locationforecast.Precipitation] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Precipitation] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Precipitation(scala.collection.immutable.ListMap(List(
        (node \ "@unit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@unit" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ },
        (node \ "@minvalue").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@minvalue" -> _ },
        (node \ "@maxvalue").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@maxvalue" -> _ },
        (node \ "@probability").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@probability" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Precipitation, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@unit", _) => attr = scala.xml.Attribute(null, "unit", __obj.unit.toString, attr)
        case ("@value", _) => attr = scala.xml.Attribute(null, "value", __obj.valueAttribute.toString, attr)
        case ("@minvalue", _) => __obj.minvalue foreach { x => attr = scala.xml.Attribute(null, "minvalue", x.toString, attr) }
        case ("@maxvalue", _) => __obj.maxvalue foreach { x => attr = scala.xml.Attribute(null, "maxvalue", x.toString, attr) }
        case ("@probability", _) => __obj.probability foreach { x => attr = scala.xml.Attribute(null, "probability", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Precipitation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastGroundcoverFormat extends scalaxb.XMLFormat[met.locationforecast.Groundcover] with scalaxb.CanWriteChildNodes[met.locationforecast.Groundcover] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Groundcover] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Groundcover(scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Groundcover, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Groundcover, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastPressureFormat extends scalaxb.XMLFormat[met.locationforecast.Pressure] with scalaxb.CanWriteChildNodes[met.locationforecast.Pressure] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Pressure] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Pressure(scala.collection.immutable.ListMap(List(
        (node \ "@unit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@unit" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Pressure, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@unit", _) => attr = scala.xml.Attribute(null, "unit", __obj.unit.toString, attr)
        case ("@value", _) => attr = scala.xml.Attribute(null, "value", __obj.valueAttribute.toString, attr)
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Pressure, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastUnit_valueFormat extends scalaxb.XMLFormat[met.locationforecast.Unit_value] with scalaxb.CanWriteChildNodes[met.locationforecast.Unit_value] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Unit_value] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Unit_value(scala.collection.immutable.ListMap(List(
        (node \ "@unit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@unit" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Unit_value, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@unit", _) => attr = scala.xml.Attribute(null, "unit", __obj.unit.toString, attr)
        case ("@value", _) => attr = scala.xml.Attribute(null, "value", __obj.valueAttribute.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Unit_value, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastUvFormat extends scalaxb.ElemNameParser[met.locationforecast.Uv] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("uv")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[met.locationforecast.Uv] =
      phrase((scalaxb.ElemName(None, "uvi_clear")) ~ 
      (scalaxb.ElemName(None, "uvi_partly_cloudy")) ~ 
      (scalaxb.ElemName(None, "uvi_cloudy")) ~ 
      (scalaxb.ElemName(None, "uvi_forecast")) ~ 
      (scalaxb.ElemName(None, "ozon")) ~ 
      (scalaxb.ElemName(None, "snowcover")) ~ 
      (scalaxb.ElemName(None, "cloudcover")) ~ 
      (scalaxb.ElemName(None, "albedo")) ~ 
      (scalaxb.ElemName(None, "solar_zenith")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      met.locationforecast.Uv(scalaxb.fromXML[met.locationforecast.Unit_value](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[met.locationforecast.Unit_value](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[met.locationforecast.Unit_value](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[met.locationforecast.Unit_value](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[met.locationforecast.Unit_value](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[met.locationforecast.Unit_value](p6, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[met.locationforecast.Unit_value](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[met.locationforecast.Unit_value](p8, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[met.locationforecast.Unit_value](p9, scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: met.locationforecast.Uv, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[met.locationforecast.Unit_value](__obj.uvi_clear, None, Some("uvi_clear"), __scope, false),
        scalaxb.toXML[met.locationforecast.Unit_value](__obj.uvi_partly_cloudy, None, Some("uvi_partly_cloudy"), __scope, false),
        scalaxb.toXML[met.locationforecast.Unit_value](__obj.uvi_cloudy, None, Some("uvi_cloudy"), __scope, false),
        scalaxb.toXML[met.locationforecast.Unit_value](__obj.uvi_forecast, None, Some("uvi_forecast"), __scope, false),
        scalaxb.toXML[met.locationforecast.Unit_value](__obj.ozon, None, Some("ozon"), __scope, false),
        scalaxb.toXML[met.locationforecast.Unit_value](__obj.snowcover, None, Some("snowcover"), __scope, false),
        scalaxb.toXML[met.locationforecast.Unit_value](__obj.cloudcover, None, Some("cloudcover"), __scope, false),
        scalaxb.toXML[met.locationforecast.Unit_value](__obj.albedo, None, Some("albedo"), __scope, false),
        scalaxb.toXML[met.locationforecast.Unit_value](__obj.solar_zenith, None, Some("solar_zenith"), __scope, false))

  }

  trait DefaultLocationforecastScoreFormat extends scalaxb.XMLFormat[met.locationforecast.Score] with scalaxb.CanWriteChildNodes[met.locationforecast.Score] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Score] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Score(scala.collection.immutable.ListMap(List(
        (node \ "@unit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@unit" -> _ },
        (node \ "@overall").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overall" -> _ },
        (node \ "@very_good").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@very_good" -> _ },
        (node \ "@good").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@good" -> _ },
        (node \ "@mediocre").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@mediocre" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Score, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@unit", _) => __obj.unit foreach { x => attr = scala.xml.Attribute(null, "unit", x.toString, attr) }
        case ("@overall", _) => __obj.overall foreach { x => attr = scala.xml.Attribute(null, "overall", x.toString, attr) }
        case ("@very_good", _) => __obj.very_good foreach { x => attr = scala.xml.Attribute(null, "very_good", x.toString, attr) }
        case ("@good", _) => __obj.good foreach { x => attr = scala.xml.Attribute(null, "good", x.toString, attr) }
        case ("@mediocre", _) => __obj.mediocre foreach { x => attr = scala.xml.Attribute(null, "mediocre", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Score, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastTidalwaterFormat extends scalaxb.XMLFormat[met.locationforecast.Tidalwater] with scalaxb.CanWriteChildNodes[met.locationforecast.Tidalwater] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Tidalwater] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Tidalwater(scala.collection.immutable.ListMap(List(
        (node \ "@unit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@unit" -> _ },
        (node \ "@tidal").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@tidal" -> _ },
        (node \ "@weathercorrection").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@weathercorrection" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Tidalwater, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@unit", _) => __obj.unit foreach { x => attr = scala.xml.Attribute(null, "unit", x.toString, attr) }
        case ("@tidal", _) => attr = scala.xml.Attribute(null, "tidal", __obj.tidal.toString, attr)
        case ("@weathercorrection", _) => __obj.weathercorrection foreach { x => attr = scala.xml.Attribute(null, "weathercorrection", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Tidalwater, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastWindDirectionFormat extends scalaxb.XMLFormat[met.locationforecast.WindDirection] with scalaxb.CanWriteChildNodes[met.locationforecast.WindDirection] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.WindDirection] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.WindDirection(scala.collection.immutable.ListMap(List(
        (node \ "@deg").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@deg" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.WindDirection, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@deg", _) => attr = scala.xml.Attribute(null, "deg", __obj.deg.toString, attr)
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.WindDirection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastStateOfTheSeaFormat extends scalaxb.XMLFormat[met.locationforecast.StateOfTheSea] with scalaxb.CanWriteChildNodes[met.locationforecast.StateOfTheSea] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.StateOfTheSea] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.StateOfTheSea(scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@meter").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@meter" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.StateOfTheSea, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@meter", _) => __obj.meter foreach { x => attr = scala.xml.Attribute(null, "meter", x.toString, attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.StateOfTheSea, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastSnowDepthFormat extends scalaxb.XMLFormat[met.locationforecast.SnowDepth] with scalaxb.CanWriteChildNodes[met.locationforecast.SnowDepth] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.SnowDepth] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.SnowDepth(scala.collection.immutable.ListMap(List(
        (node \ "@cm").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@cm" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.SnowDepth, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@cm", _) => attr = scala.xml.Attribute(null, "cm", __obj.cm.toString, attr)
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.SnowDepth, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastWeatherFormat extends scalaxb.XMLFormat[met.locationforecast.Weather] with scalaxb.CanWriteChildNodes[met.locationforecast.Weather] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Weather] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Weather(scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@symbol").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@symbol" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Weather, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@number", _) => attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@symbol", _) => __obj.symbol foreach { x => attr = scala.xml.Attribute(null, "symbol", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Weather, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastSymbolFormat extends scalaxb.XMLFormat[met.locationforecast.Symbol] with scalaxb.CanWriteChildNodes[met.locationforecast.Symbol] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Symbol] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Symbol(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Symbol, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@number", _) => attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Symbol, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastForestu45fireFormat extends scalaxb.XMLFormat[met.locationforecast.Forestu45fire] with scalaxb.CanWriteChildNodes[met.locationforecast.Forestu45fire] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.Forestu45fire] = seq match {
      case node: scala.xml.Node => Right(met.locationforecast.Forestu45fire(scala.collection.immutable.ListMap(List(
        (node \ "@unit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@unit" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: met.locationforecast.Forestu45fire, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@unit", _) => __obj.unit foreach { x => attr = scala.xml.Attribute(null, "unit", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.Forestu45fire, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultLocationforecastLocationTypeFormat extends scalaxb.ElemNameParser[met.locationforecast.LocationType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("locationType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[met.locationforecast.LocationType] =
      phrase(safeRep((opt(scalaxb.ElemName(None, "groundCover")) ~ 
      opt(scalaxb.ElemName(None, "pressure")) ~ 
      opt(scalaxb.ElemName(None, "maximumPrecipitation")) ~ 
      opt(scalaxb.ElemName(None, "highestTemperature")) ~ 
      opt(scalaxb.ElemName(None, "lowestTemperature")) ~ 
      opt(scalaxb.ElemName(None, "precipitation")) ~ 
      opt(scalaxb.ElemName(None, "fog")) ~ 
      opt(scalaxb.ElemName(None, "cloudiness")) ~ 
      opt(scalaxb.ElemName(None, "lowClouds")) ~ 
      opt(scalaxb.ElemName(None, "mediumClouds")) ~ 
      opt(scalaxb.ElemName(None, "highClouds")) ~ 
      opt(scalaxb.ElemName(None, "temperature")) ~ 
      opt(scalaxb.ElemName(None, "dewpointTemperature")) ~ 
      opt(scalaxb.ElemName(None, "minTemperature")) ~ 
      opt(scalaxb.ElemName(None, "minTemperatureDay")) ~ 
      opt(scalaxb.ElemName(None, "minTemperatureNight")) ~ 
      opt(scalaxb.ElemName(None, "maxTemperature")) ~ 
      opt(scalaxb.ElemName(None, "maxTemperatureDay")) ~ 
      opt(scalaxb.ElemName(None, "maxTemperatureNight")) ~ 
      opt(scalaxb.ElemName(None, "uv")) ~ 
      opt(scalaxb.ElemName(None, "tidalwater")) ~ 
      opt(scalaxb.ElemName(None, "currentDirection")) ~ 
      opt(scalaxb.ElemName(None, "maxWaveHeight")) ~ 
      opt(scalaxb.ElemName(None, "surfaceTemperature")) ~ 
      opt(scalaxb.ElemName(None, "waveDirection")) ~ 
      opt(scalaxb.ElemName(None, "wavePeriod")) ~ 
      opt(scalaxb.ElemName(None, "waveHeight")) ~ 
      opt(scalaxb.ElemName(None, "humidity")) ~ 
      opt(scalaxb.ElemName(None, "bias")) ~ 
      opt(scalaxb.ElemName(None, "numberofobservations")) ~ 
      opt(scalaxb.ElemName(None, "meanabsoluteerror")) ~ 
      opt(scalaxb.ElemName(None, "score")) ~ 
      opt(scalaxb.ElemName(None, "windDirection")) ~ 
      opt(scalaxb.ElemName(None, "windSpeed")) ~ 
      opt(scalaxb.ElemName(None, "windGust")) ~ 
      opt(scalaxb.ElemName(None, "maxWindSpeed")) ~ 
      opt(scalaxb.ElemName(None, "stateOfTheSea")) ~ 
      opt(scalaxb.ElemName(None, "snowDepth")) ~ 
      opt(scalaxb.ElemName(None, "weather")) ~ 
      opt(scalaxb.ElemName(None, "symbol")) ~ 
      opt(scalaxb.ElemName(None, "forest-fire")) ~ 
      opt(scalaxb.ElemName(None, "windProbability")) ~ 
      opt(scalaxb.ElemName(None, "temperatureProbability")) ~ 
      opt(scalaxb.ElemName(None, "symbolProbability"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 ~ p16 ~ p17 ~ p18 ~ p19 ~ p20 ~ p21 ~ p22 ~ p23 ~ p24 ~ p25 ~ p26 ~ p27 ~ p28 ~ p29 ~ p30 ~ p31 ~ p32 ~ p33 ~ p34 ~ p35 ~ p36 ~ p37 ~ p38 ~ p39 ~ p40 ~ p41 ~ p42 ~ p43 ~ p44 => met.locationforecast.LocationTypeSequence1(p1.headOption map { scalaxb.fromXML[met.locationforecast.Groundcover](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[met.locationforecast.Pressure](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[met.locationforecast.Precipitation](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[met.locationforecast.Temperature](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[met.locationforecast.Temperature](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[met.locationforecast.Precipitation](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[met.locationforecast.Cloudiness](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[met.locationforecast.Cloudiness](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[met.locationforecast.Cloudiness](_, scalaxb.ElemName(node) :: stack) },
        p10.headOption map { scalaxb.fromXML[met.locationforecast.Cloudiness](_, scalaxb.ElemName(node) :: stack) },
        p11.headOption map { scalaxb.fromXML[met.locationforecast.Cloudiness](_, scalaxb.ElemName(node) :: stack) },
        p12.headOption map { scalaxb.fromXML[met.locationforecast.Temperature](_, scalaxb.ElemName(node) :: stack) },
        p13.headOption map { scalaxb.fromXML[met.locationforecast.Temperature](_, scalaxb.ElemName(node) :: stack) },
        p14.headOption map { scalaxb.fromXML[met.locationforecast.Temperature](_, scalaxb.ElemName(node) :: stack) },
        p15.headOption map { scalaxb.fromXML[met.locationforecast.Temperature](_, scalaxb.ElemName(node) :: stack) },
        p16.headOption map { scalaxb.fromXML[met.locationforecast.Temperature](_, scalaxb.ElemName(node) :: stack) },
        p17.headOption map { scalaxb.fromXML[met.locationforecast.Temperature](_, scalaxb.ElemName(node) :: stack) },
        p18.headOption map { scalaxb.fromXML[met.locationforecast.Temperature](_, scalaxb.ElemName(node) :: stack) },
        p19.headOption map { scalaxb.fromXML[met.locationforecast.Temperature](_, scalaxb.ElemName(node) :: stack) },
        p20.headOption map { scalaxb.fromXML[met.locationforecast.Uv](_, scalaxb.ElemName(node) :: stack) },
        p21.headOption map { scalaxb.fromXML[met.locationforecast.Tidalwater](_, scalaxb.ElemName(node) :: stack) },
        p22.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p23.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p24.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p25.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p26.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p27.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p28.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p29.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p30.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p31.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p32.headOption map { scalaxb.fromXML[met.locationforecast.Score](_, scalaxb.ElemName(node) :: stack) },
        p33.headOption map { scalaxb.fromXML[met.locationforecast.WindDirection](_, scalaxb.ElemName(node) :: stack) },
        p34.headOption map { scalaxb.fromXML[met.locationforecast.Windspeed](_, scalaxb.ElemName(node) :: stack) },
        p35.headOption map { scalaxb.fromXML[met.locationforecast.Windspeed](_, scalaxb.ElemName(node) :: stack) },
        p36.headOption map { scalaxb.fromXML[met.locationforecast.Windspeed](_, scalaxb.ElemName(node) :: stack) },
        p37.headOption map { scalaxb.fromXML[met.locationforecast.StateOfTheSea](_, scalaxb.ElemName(node) :: stack) },
        p38.headOption map { scalaxb.fromXML[met.locationforecast.SnowDepth](_, scalaxb.ElemName(node) :: stack) },
        p39.headOption map { scalaxb.fromXML[met.locationforecast.Weather](_, scalaxb.ElemName(node) :: stack) },
        p40.headOption map { scalaxb.fromXML[met.locationforecast.Symbol](_, scalaxb.ElemName(node) :: stack) },
        p41.headOption map { scalaxb.fromXML[met.locationforecast.Forestu45fire](_, scalaxb.ElemName(node) :: stack) },
        p42.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p43.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) },
        p44.headOption map { scalaxb.fromXML[met.locationforecast.Unit_value](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 =>
      met.locationforecast.LocationType(p1.toSeq,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@stationid").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@stationid" -> _ },
        (node \ "@country").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@country" -> _ },
        (node \ "@county").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@county" -> _ },
        (node \ "@latitude").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@latitude" -> _ },
        (node \ "@longitude").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@longitude" -> _ },
        (node \ "@altitude").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@altitude" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: met.locationforecast.LocationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@stationid", _) => __obj.stationid foreach { x => attr = scala.xml.Attribute(null, "stationid", x.toString, attr) }
        case ("@country", _) => __obj.country foreach { x => attr = scala.xml.Attribute(null, "country", x.toString, attr) }
        case ("@county", _) => __obj.county foreach { x => attr = scala.xml.Attribute(null, "county", x.toString, attr) }
        case ("@latitude", _) => __obj.latitude foreach { x => attr = scala.xml.Attribute(null, "latitude", x.toString, attr) }
        case ("@longitude", _) => __obj.longitude foreach { x => attr = scala.xml.Attribute(null, "longitude", x.toString, attr) }
        case ("@altitude", _) => __obj.altitude foreach { x => attr = scala.xml.Attribute(null, "altitude", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: met.locationforecast.LocationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.locationtypesequence1 flatMap { scalaxb.toXML[met.locationforecast.LocationTypeSequence1](_, None, Some("locationtypesequence1"), __scope, false) })

  }

  trait DefaultLocationforecastLocationTypeSequence1Format extends scalaxb.XMLFormat[met.locationforecast.LocationTypeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, met.locationforecast.LocationTypeSequence1] = Left("don't call me.")
    
    def writes(__obj: met.locationforecast.LocationTypeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.groundCover map { scalaxb.toXML[met.locationforecast.Groundcover](_, None, Some("groundCover"), __scope, false) } getOrElse {Nil},
        __obj.pressure map { scalaxb.toXML[met.locationforecast.Pressure](_, None, Some("pressure"), __scope, false) } getOrElse {Nil},
        __obj.maximumPrecipitation map { scalaxb.toXML[met.locationforecast.Precipitation](_, None, Some("maximumPrecipitation"), __scope, false) } getOrElse {Nil},
        __obj.highestTemperature map { scalaxb.toXML[met.locationforecast.Temperature](_, None, Some("highestTemperature"), __scope, false) } getOrElse {Nil},
        __obj.lowestTemperature map { scalaxb.toXML[met.locationforecast.Temperature](_, None, Some("lowestTemperature"), __scope, false) } getOrElse {Nil},
        __obj.precipitation map { scalaxb.toXML[met.locationforecast.Precipitation](_, None, Some("precipitation"), __scope, false) } getOrElse {Nil},
        __obj.fog map { scalaxb.toXML[met.locationforecast.Cloudiness](_, None, Some("fog"), __scope, false) } getOrElse {Nil},
        __obj.cloudiness map { scalaxb.toXML[met.locationforecast.Cloudiness](_, None, Some("cloudiness"), __scope, false) } getOrElse {Nil},
        __obj.lowClouds map { scalaxb.toXML[met.locationforecast.Cloudiness](_, None, Some("lowClouds"), __scope, false) } getOrElse {Nil},
        __obj.mediumClouds map { scalaxb.toXML[met.locationforecast.Cloudiness](_, None, Some("mediumClouds"), __scope, false) } getOrElse {Nil},
        __obj.highClouds map { scalaxb.toXML[met.locationforecast.Cloudiness](_, None, Some("highClouds"), __scope, false) } getOrElse {Nil},
        __obj.temperature map { scalaxb.toXML[met.locationforecast.Temperature](_, None, Some("temperature"), __scope, false) } getOrElse {Nil},
        __obj.dewpointTemperature map { scalaxb.toXML[met.locationforecast.Temperature](_, None, Some("dewpointTemperature"), __scope, false) } getOrElse {Nil},
        __obj.minTemperature map { scalaxb.toXML[met.locationforecast.Temperature](_, None, Some("minTemperature"), __scope, false) } getOrElse {Nil},
        __obj.minTemperatureDay map { scalaxb.toXML[met.locationforecast.Temperature](_, None, Some("minTemperatureDay"), __scope, false) } getOrElse {Nil},
        __obj.minTemperatureNight map { scalaxb.toXML[met.locationforecast.Temperature](_, None, Some("minTemperatureNight"), __scope, false) } getOrElse {Nil},
        __obj.maxTemperature map { scalaxb.toXML[met.locationforecast.Temperature](_, None, Some("maxTemperature"), __scope, false) } getOrElse {Nil},
        __obj.maxTemperatureDay map { scalaxb.toXML[met.locationforecast.Temperature](_, None, Some("maxTemperatureDay"), __scope, false) } getOrElse {Nil},
        __obj.maxTemperatureNight map { scalaxb.toXML[met.locationforecast.Temperature](_, None, Some("maxTemperatureNight"), __scope, false) } getOrElse {Nil},
        __obj.uv map { scalaxb.toXML[met.locationforecast.Uv](_, None, Some("uv"), __scope, false) } getOrElse {Nil},
        __obj.tidalwater map { scalaxb.toXML[met.locationforecast.Tidalwater](_, None, Some("tidalwater"), __scope, false) } getOrElse {Nil},
        __obj.currentDirection map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("currentDirection"), __scope, false) } getOrElse {Nil},
        __obj.maxWaveHeight map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("maxWaveHeight"), __scope, false) } getOrElse {Nil},
        __obj.surfaceTemperature map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("surfaceTemperature"), __scope, false) } getOrElse {Nil},
        __obj.waveDirection map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("waveDirection"), __scope, false) } getOrElse {Nil},
        __obj.wavePeriod map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("wavePeriod"), __scope, false) } getOrElse {Nil},
        __obj.waveHeight map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("waveHeight"), __scope, false) } getOrElse {Nil},
        __obj.humidity map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("humidity"), __scope, false) } getOrElse {Nil},
        __obj.bias map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("bias"), __scope, false) } getOrElse {Nil},
        __obj.numberofobservations map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("numberofobservations"), __scope, false) } getOrElse {Nil},
        __obj.meanabsoluteerror map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("meanabsoluteerror"), __scope, false) } getOrElse {Nil},
        __obj.score map { scalaxb.toXML[met.locationforecast.Score](_, None, Some("score"), __scope, false) } getOrElse {Nil},
        __obj.windDirection map { scalaxb.toXML[met.locationforecast.WindDirection](_, None, Some("windDirection"), __scope, false) } getOrElse {Nil},
        __obj.windSpeed map { scalaxb.toXML[met.locationforecast.Windspeed](_, None, Some("windSpeed"), __scope, false) } getOrElse {Nil},
        __obj.windGust map { scalaxb.toXML[met.locationforecast.Windspeed](_, None, Some("windGust"), __scope, false) } getOrElse {Nil},
        __obj.maxWindSpeed map { scalaxb.toXML[met.locationforecast.Windspeed](_, None, Some("maxWindSpeed"), __scope, false) } getOrElse {Nil},
        __obj.stateOfTheSea map { scalaxb.toXML[met.locationforecast.StateOfTheSea](_, None, Some("stateOfTheSea"), __scope, false) } getOrElse {Nil},
        __obj.snowDepth map { scalaxb.toXML[met.locationforecast.SnowDepth](_, None, Some("snowDepth"), __scope, false) } getOrElse {Nil},
        __obj.weather map { scalaxb.toXML[met.locationforecast.Weather](_, None, Some("weather"), __scope, false) } getOrElse {Nil},
        __obj.symbol map { scalaxb.toXML[met.locationforecast.Symbol](_, None, Some("symbol"), __scope, false) } getOrElse {Nil},
        __obj.forestu45fire map { scalaxb.toXML[met.locationforecast.Forestu45fire](_, None, Some("forest-fire"), __scope, false) } getOrElse {Nil},
        __obj.windProbability map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("windProbability"), __scope, false) } getOrElse {Nil},
        __obj.temperatureProbability map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("temperatureProbability"), __scope, false) } getOrElse {Nil},
        __obj.symbolProbability map { scalaxb.toXML[met.locationforecast.Unit_value](_, None, Some("symbolProbability"), __scope, false) } getOrElse {Nil})


  }


}

